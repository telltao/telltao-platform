包结构说明
Collection为全部集合的顶层接口实现他们的有
    Set(存储不可重复的集合),
    List(有序集合（也称为序列)),
    Queue(处理之前容纳元素的集合)
    等

Set:

    不包含重复元素的集合。 更正式地讲，集合不包含元素e1和e2对，使得e1.equals(e2)最多包含一个null元素。 顾名思义，此接口对数学集合抽象进行建模。
    除了从Collection接口继承的规定之外， Set接口还对所有构造函数的协定以及add ， equals和hashCode方法的协定附加其他规定。 为方便起见，此处还包含其他继承方法的声明。
    （这些声明随附的规范是针对Set接口量身定制的，但不包含任何其他规定。）
    毫不奇怪，对构造函数的附加规定是，所有构造函数都必须创建一个不包含重复元素的集合（如上定义）。
    注意：如果将可变对象用作集合元素，则必须格外小心。 如果对象的值更改为影响equals比较的方式，而该对象是集合中的元素，则不指定集合的​​行为。 此禁止的一种特殊情况是，不允许集合将自身包含为元素。
    一些集合实现对它们可能包含的元素有限制。 例如，某些实现禁止使用null元素，而某些实现对其元素的类型有限制。 尝试添加不合格元素会引发未经检查的异常，通常是NullPointerException或ClassCastException 。
     尝试查询不合格元素的存在可能会引发异常，或者可能仅返回false；否则，可能会返回false。
     一些实现将表现出前一种行为，而某些将表现出后者。 更一般地，尝试对不合格元素进行操作，该操作的完成不会导致将不合格元素插入到集合中，这可能会导致异常或成功实现，具体取决于实现方式。 此类异常在此接口的规范中标记为“可选”。
    不可修改的集合
    Set.of和Set.copyOf静态工厂方法提供了一种创建不可修改集的便捷方法。 这些方法创建的Set实例具有以下特征：
    它们是不可修改的。 元素无法添加或删除。 在Set上调用任何mutator方法将始终导致抛出UnsupportedOperationException 。 但是，如果所包含的元素本身是可变的，则可能导致Set行为不一致或其内容似乎发生变化。
    他们不允许使用null元素。 尝试使用null元素创建它们会导致NullPointerException 。
    如果所有元素都是可序列化的，则它们是可序列化的。
    他们在创建时拒绝重复的元素。 传递给静态工厂方法的重复元素导致IllegalArgumentException 。
    set元素的迭代顺序未指定，可能会发生变化。
    它们是基于价值的。 调用者不应对返回实例的身份做任何假设。 工厂可以自由创建新实例或重用现有实例。 因此，在这些实例上的身份敏感操作（引用相等（ == ），身份哈希码和同步）不可靠，应避免。
    它们按照“序列化表格”页面上的指定进行序列化。
    该接口是Java Collections Framework的成员。

List:
    有序集合（也称为序列）。
    该界面的用户可以精确控制列表中每个元素的插入位置。 用户可以通过其整数索引（列表中的位置）访问元素，并在列表中搜索元素。
    与集合不同，列表通常允许重复的元素。 更正式地讲，列表通常允许成对的元素e1和e2 ，使得e1.equals(e2) ，并且如果它们完全允许空元素，则它们通常允许多个空元素。
     并非不可想象的是，有人希望通过在用户尝试插入运行时异常时抛出运行时异常来实现禁止重复的列表，但是我们希望这种用法很少见。
    除了在Collection接口中指定的规定外， List接口还对iterator ， add ， remove ， equals和hashCode方法的协定add其他规定。 为方便起见，此处还包含其他继承方法的声明。
    List接口提供了四种位置（索引）访问列表元素的方法。 列表（如Java数组）从零开始。 请注意，对于某些实现（例如， LinkedList类），这些操作可能在时间上与索引值成比例执行。
    因此，如果调用者不知道实现，则遍历列表中的元素通常比对其进行索引更可取。
    List接口提供了一个称为ListIterator的特殊迭代器，除了Iterator接口提供的常规操作之外，该Iterator还允许元素插入和替换以及双向访问。
    提供了一种获取列表迭代器的方法，该列表迭代器从列表中的指定位置开始。
    List接口提供了两种搜索指定对象的方法。 从性能的角度来看，应谨慎使用这些方法。 在许多实现中，它们将执行昂贵的线性搜索。
    List接口提供了两种方法，可以有效地在列表中的任意点插入和删除多个元素。
    注意：尽管允许列表将自身包含为元素，但建议格外小心： equals和hashCode方法在这样的列表上不再定义良好。
    一些列表实现对它们可能包含的元素有限制。 例如，某些实现禁止使用null元素，而某些实现对其元素的类型有限制。
    尝试添加不合格元素会引发未经检查的异常，通常是NullPointerException或ClassCastException 。
    尝试查询不合格元素的存在可能会引发异常，或者可能仅返回false；否则，可能会返回false。
    一些实现将表现出前一种行为，而某些将表现出后者。 更一般地，尝试对不合格元素进行操作，该操作的完成不会导致将不合格元素插入列表中，这可能会导致异常或成功实现，具体取决于实现方式。
    此类异常在此接口的规范中标记为“可选”。

    不可修改的清单
    List.of和List.copyOf静态工厂方法提供了一种创建不可修改列表的便捷方法。 这些方法创建的List实例具有以下特征：
    它们是不可修改的。 元素无法添加，删除或替换。 调用List上的任何mutator方法将始终引发UnsupportedOperationException 。
    但是，如果所包含的元素本身是可变的，则可能导致列表的内容似乎发生变化。
    他们不允许使用null元素。 尝试使用null元素创建它们会导致NullPointerException 。
    如果所有元素都是可序列化的，则它们是可序列化的。
    列表中元素的顺序与提供的参数或提供的数组中的元素的顺序相同。
    它们是基于价值的。 调用者不应对返回实例的身份做任何假设。 工厂可以自由创建新实例或重用现有实例。
    因此，在这些实例上的身份敏感操作（引用相等（ == ），身份哈希码和同步）不可靠，应避免。
    它们按照“序列化表格”页面上的指定进行序列化。
    该接口是Java Collections Framework的成员。
    
Queue:

    设计用于在处理之前容纳元素的集合。 除了基本的“ Collection操作外，队列还提供其他插入，提取和检查操作。
    这些方法中的每一种都以两种形式存在：一种在操作失败时引发异常，另一种返回一个特殊值（取决于操作，为null或false ）。
    插入操作的后一种形式是专门为与容量受限的Queue实现一起使用而设计的； 在大多数实现中，插入操作不会失败。
    队列方法摘要

    引发异常
    返回特殊值
    插  add(e)  offer(e)
    去掉 remove() poll()
    检查 element() peek()
    队列通常但不一定以FIFO（先进先出）的方式对元素进行排序。 例外情况包括优先级队列（根据提供的比较器对元素进行排序或元素的自然排序）和LIFO队列（或堆栈），对LIFO进行排序（后进先出）。
    无论使用哪种顺序，队列的开头都是该元素，可以通过调用remove()或poll()来remove()该元素。
    在FIFO队列中，所有新元素都插入队列的尾部。 其他种类的队列可能使用不同的放置规则。 每个Queue实现必须指定其排序属性。
    offer方法在可能的情况下插入一个元素，否则返回false 。 这不同于Collection.add方法，后者只能通过抛出未经检查的异常来添加元素。
    offer方法设计用于在正常情况下（而不是在异常情况下）发生故障时，例如在固定容量（或“有界”）队列中使用。
    remove()和poll()方法删除并返回队列的头部。 确切地说，从队列中删除了哪个元素是队列的排序策略的函数，每个实现的实现方法不同。
    remove()和poll()方法的区别仅在于队列为空时它们的行为不同： remove()方法引发异常，而poll()方法返回null 。
    element()和peek()方法返回但不删除队列的头部。
    Queue接口没有定义并发编程中常见的阻塞队列方法。 这些方法等待元素出现或空间可用，这些方法在java.util.concurrent.BlockingQueue接口中定义，该接口扩展了该接口。
    Queue实现通常不允许插入null元素，尽管某些实现（例如LinkedList ）不禁止插入null 。
    即使在允许的实现中，也不应将null插入Queue ，因为poll方法还将null用作特殊的返回值，以指示该队列不包含任何元素。
    Queue实现通常不定义方法equals和hashCode的基于元素的版本，而是从Object类继承基于身份的版本，因为对于具有相同元素但顺序属性不同的队列，基于元素的相等性并不总是很好定义的。
    该接口是Java Collections Framework的成员。


##### 


